workflow:
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        VERSION: "$CI_COMMIT_TAG"
        ENV_HOST: comentario.app

    - if: $CI_COMMIT_BRANCH == "dev"
      variables:
        VERSION: "$CI_COMMIT_BRANCH-$CI_COMMIT_SHORT_SHA"
        ENV_HOST: edge.comentario.app

stages:
  - build
  - test
  - package
  - release
  - deploy
  - post-deploy

variables:
  CI_TOOLS_VERSION: "v25"
  DEPLOYER_IMAGE: "alpine/k8s:1.28.2"
  # Namespace to deploy Kubernetes objects into
  NAMESPACE: ys-comentario
  SKIP_TESTS:
    value: "false"
    description: Whether to skip executing front-end tests

build:
  stage: build
  image: registry.gitlab.com/comentario/comentario-ci-tools/builder:$CI_TOOLS_VERSION
  artifacts:
    when: always
    name: comentario
    expire_in: 1 days  # Only keep the last batch
    paths:
      - build/
      - build-e2e/
      - dist/
      - node_modules/
  variables:
    # We want to store downloaded packages under the project dir, so we can cache them
    GOPATH: $CI_PROJECT_DIR/.go
  cache:
    key:
      files:
        # Backend
        - go.mod
        # Frontend
        - yarn.lock
    paths:
      # Backend
      - .go/pkg/mod/
      # Frontend
      - .yarn-cache/
  before_script:
    # Create the required dirs
    - mkdir -p build build-e2e .go
  script:
    # Backend build
    - go generate               # Generate code
    - go mod download           # Fetch the dependencies explicitly (not exactly necessary, but makes it easier to spot problems)
    - test -z "$(go fmt ./...)" # Make sure there are no formatting issues
    - go test -v ./...          # Run unit tests

    # End-2-end: build the backend, e2e plugin and relay
    - go build -v 
        -o "./build-e2e/comentario" 
        -ldflags "-X main.version=$(git describe --tags) -X main.date=$(date --iso-8601=seconds)"
    - go build -buildmode=plugin -o "./build-e2e/comentario-e2e.so" "./e2e/plugin/"
    - go build -v -o "./build-e2e/comentario-relay" "./e2e/relay/"

    # Production backend build: disable CGO to statically link the executable so that we can run that in Alpine
    - CGO_ENABLED=0 go build -a -v
      -o "./build/comentario"
      -ldflags "-w -s -X main.version=$(git describe --tags) -X main.date=$(date --iso-8601=seconds)"

    # Copy static assets
    - cp -r db/ templates/ build/

    # Frontend build
    - yarn install 
        --frozen-lockfile 
        --no-progress 
        --cache-folder .yarn-cache    # Fetch the dependencies
    - yarn run generate               # Generate the API client
    - yarn run lint                   # Lint
    - yarn run test:ci                # Run unit tests
    - yarn run build:prod             # Build

    # Debug output
    - git status -v

    # Build source and binary packages using goreleaser
    - goreleaser_opts='--clean --skip=publish'
    - if [[ -z "$CI_COMMIT_TAG" ]]; then
    -     goreleaser_opts="$goreleaser_opts --snapshot"
    - fi
    - goreleaser release $goreleaser_opts

e2e:
  stage: test
  rules:
    - if: $SKIP_TESTS != 'true'
  image: registry.gitlab.com/comentario/comentario-ci-tools/builder:$CI_TOOLS_VERSION
  parallel:
    # Test against all supported PostgreSQL versions
    matrix:
      - POSTGRES_IMAGE:
          - postgres:16-alpine
          - postgres:15-alpine
          - postgres:14-alpine
          - postgres:13-alpine
          - postgres:12-alpine
          - postgres:11-alpine
          - postgres:10-alpine
  retry: 1
  artifacts:
    when: always
    name: comentario
    expire_in: 1 days  # Only keep the last batch
    paths:
      - cypress/screenshots
      - cypress/videos
      - tmp/logs
  variables:
    # We want to store downloaded packages under the project dir, so we can cache them
    GOPATH: $CI_PROJECT_DIR/.go
  services:
    - name: $POSTGRES_IMAGE
      variables:
        POSTGRES_DB: comentario
        POSTGRES_USER: postgres
        POSTGRES_PASSWORD: postgres
    # The test-site service. Its URL (mentioned in CYPRESS_TEST_SITE_URL) must match the host (alias)
    - name: registry.gitlab.com/comentario/comentario-ci-tools/test-site:$CI_TOOLS_VERSION
      alias: comentario-test-site
  dependencies:
    - build
  before_script:
    # Create the required dirs
    - mkdir -p tmp/logs
  script:
    # Wait for HTTP server using the given URL
    - |
      waitFor() {
          i=0
          while ((i++ < 30)); do
              curl --max-time 2 -vs "$1" >/dev/null && break
              sleep 1
          done
          if [[ $i -ge 30 ]]; then
              echo "ERROR: $1 is not reachable after $i seconds, failing"
              exit 1
          fi 
      }

    # Start the e2e backend
    - ./build-e2e/comentario -vv
          --e2e
          --port=8080
          --static-path=build/frontend
          --db-migration-path=build/db
          --template-path=build/templates
          --secrets=resources/k8s/secrets.yaml
          --base-docs-url="https://edge.docs.comentario.app"
          --home-content-url="https://edge.docs.comentario.app/en/embed/front-page/"
          &> ./tmp/logs/comentario-server.log &
    - waitFor http://localhost:8080/en/

    # Start the relay to pass localhost:8000 requests through to comentario-test-site:80
    - ./build-e2e/comentario-relay 
          -listen 127.0.0.1:8000
          -target http://comentario-test-site
          &> ./tmp/logs/comentario-relay.log &
    - waitFor http://localhost:8000/comments/

     # Run e2e tests
    - npx cypress install
    - npx cypress run

docker-image:
  stage: package
  image: docker
  services:
    - docker:dind
  dependencies:
    - build
  variables:
    IMG_TAG_CURRENT: $CI_REGISTRY_IMAGE:$VERSION
    IMG_TAG_LATEST:  $CI_REGISTRY_IMAGE:latest
  script:
    # Login to the Container Registry
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

    # Remove the e2e plugin (it isn't supposed to be in the image)
    - rm -f build/comentario-e2e.so

    # Build and push the image
    - docker build -t "$IMG_TAG_CURRENT" .
    - docker push "$IMG_TAG_CURRENT"

    # For dev, also push it as 'latest'
    - |
      if [[ "$CI_COMMIT_BRANCH" == "dev" ]]; then
          docker tag "$IMG_TAG_CURRENT" "$IMG_TAG_LATEST"
          docker push "$IMG_TAG_LATEST"
      fi

# Verify the .deb package
verify-package-deb:
  stage: package
  image: ubuntu:22.04
  dependencies:
    - build
  before_script:
    # Install systemd to fulfill the requirements
    - apt-get update
    - apt-get install -y systemd
  script:
    # Install the package
    - pkg_name="$(find dist -maxdepth 1 -name '*.deb')"
    - '[[ -z "$pkg_name" ]] && echo "Failed to find the .deb package" && exit 1'
    - dpkg -i "$pkg_name"

    # We won't really start the service because it's way too much hassle to get systemd operational inside a container.
    # For now, an installable package is good enough
    - test -s /etc/comentario/comentario.conf
    - test -s /etc/comentario/secrets.yaml
    - test -x /usr/bin/comentario
    - test -d /usr/lib/comentario/db
    - test -s /usr/lib/comentario/frontend/comentario.css
    - test -s /usr/lib/comentario/frontend/comentario.js
    - test -s /usr/lib/comentario/frontend/favicon.ico
    - test -s /usr/lib/comentario/frontend/en/index.html
    - test -d /usr/lib/comentario/templates
    - test -s /usr/lib/systemd/system/comentario.service

# Verify the .rpm package
verify-package-rpm:
  stage: package
  image: centos:7
  dependencies:
    - build
  before_script:
    # Install systemd to fulfill the requirements
    - yum install -y systemd
  script:
    # Install the package
    - pkg_name="$(find dist -maxdepth 1 -name '*.rpm')"
    - '[[ -z "$pkg_name" ]] && echo "Failed to find the .rpm package" && exit 1'
    - rpm -i "$pkg_name"

    # We won't really start the service because it's way too much hassle to get systemd operational inside a container.
    # For now, an installable package is good enough
    - test -s /etc/comentario/comentario.conf
    - test -s /etc/comentario/secrets.yaml
    - test -x /usr/bin/comentario
    - test -d /usr/lib/comentario/db
    - test -s /usr/lib/comentario/frontend/comentario.css
    - test -s /usr/lib/comentario/frontend/comentario.js
    - test -s /usr/lib/comentario/frontend/favicon.ico
    - test -s /usr/lib/comentario/frontend/en/index.html
    - test -d /usr/lib/comentario/templates
    - test -s /usr/lib/systemd/system/comentario.service

release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    - if: $CI_COMMIT_TAG
  before_script:
    # Install curl, jq
    - apk add --no-cache curl jq
  script:
    # Strip the 'v' prefix from the version number
    - ver_num="${VERSION#v}"
    - package_registry_url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/comentario/$ver_num"

    # Upload the packages
    - |
      jq -r '.[] | select(.type != "Binary") | .path' dist/artifacts.json | 
          while read artifact; do
              echo "Uploading artifact $artifact to $package_registry_url"
              curl -fsS \
                  --header "JOB-TOKEN: $CI_JOB_TOKEN" \
                  --upload-file "$artifact" "$package_registry_url/$(basename "$artifact")"
          done

    # Extract the release text from CHANGELOG.md
    - awk "/^##\s+$VERSION/{flag=1; next} /^##\s+/{flag=0} flag" CHANGELOG.md > release-text
    - |
      if [[ ! -s release-text ]]; then
          echo "Failed to extract release text for $VERSION from CHANGELOG.md"
          exit 1
      fi

    # Create a release
    - |
      echo "Creating release $CI_COMMIT_TAG"
      assets="$(jq -r --arg URL "$package_registry_url" '[.[] | select(.type != "Binary") | {name, url: "\($URL)/\(.name)"}]' dist/artifacts.json)"
      echo "Publishing assets:"
      echo "$assets"
      release-cli create \
          --name "$CI_COMMIT_TAG" \ 
          --tag-name "$CI_COMMIT_TAG" \
          --description release-text \
          --assets-link "$assets"

# Deploy the dev branch to edge.comentario.app
deploy-dev:
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"
  image: $DEPLOYER_IMAGE
  environment:
    name: edge.comentario.app
  script:
    # Use the Kubernetes context from GitLab agent
    - kubectl config use-context comentario/comentario-ci-tools:ys-comentario

    # Perform chart installation/upgrade (edge.comentario.app), waiting for it to complete (up to two minutes)
    - helm upgrade
        --namespace $NAMESPACE
        --install
        --set "clusterIssuer=letsencrypt-prod"
        --set "image.repository=$CI_REGISTRY_IMAGE"
        --set "image.tag=$VERSION"
        --set "comentario.baseDocsUrl=https://edge.docs.comentario.app/"
        --set "comentario.homeContentURL=https://edge.docs.comentario.app/en/embed/edge-front-page/"
        --set "comentario.emailFrom=noreply@yktoo.com"
        --set "comentario.secretName=comentario-edge-secrets"
        --set "ingress.host=edge.comentario.app"
        --wait
        --timeout 2m
        comentario-edge
        resources/helm/comentario

    # Deploy the recreate demo DB cronjob
    - helm upgrade
        --namespace $NAMESPACE
        --install
        --set "database.secretName=comentario-edge-secrets"
        --wait
        --timeout 1m
        comentario-demo-recreate-db
        resources/helm/demo-recreate-db

    # Trigger the job right away
    - kubectl create job
        --namespace $NAMESPACE
        --from=cronjob/comentario-demo-recreate-db-cronjob
        comentario-demo-recreate-db-cronjob-$(date +%s)

# Allow manual deployment of any tag to production
deploy-tag:
  stage: deploy
  rules:
    - if: $CI_COMMIT_TAG
      when: manual
  image: $DEPLOYER_IMAGE
  environment:
    name: comentario.app
  script:
    # Use the Kubernetes context from GitLab agent
    - kubectl config use-context comentario/comentario-ci-tools:ys-comentario

    # Perform chart installation/upgrade (comentario.app), waiting for it to complete (up to two minutes)
    - helm upgrade
        --namespace $NAMESPACE
        --install
        --set "clusterIssuer=letsencrypt-prod"
        --set "image.repository=$CI_REGISTRY_IMAGE"
        --set "image.tag=$VERSION"
        --set "comentario.emailFrom=noreply@yktoo.com"
        --set "comentario.secretName=comentario-app-secrets"
        --set "ingress.host=comentario.app"
        --wait
        --timeout 2m
        comentario-app
        resources/helm/comentario

smoke-test:
  stage: post-deploy
  rules:
    # Only makes sense if deploy has run
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_TAG && $CI_COMMIT_TAG !~ /rc/i
  image: curlimages/curl:latest
  dependencies: []  # Do not download any artifacts
  script:
    # Check function. Synopsis: checkRedirect <URL> <Expected Location>
    - |
      checkRedirect() {
        curl -fisS "$1" | grep -i 'Location:' | tr -d '\r' | cut -d ' ' -f 2 | grep -Fx "$2"
      }

    # Check basic redirections
    - checkRedirect http://$ENV_HOST/  https://$ENV_HOST/
    - checkRedirect https://$ENV_HOST/ /en/
